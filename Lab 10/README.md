
## Керування процесами-транзакціями в базах даних

### 1 Теоретичне завдання зі створення історій виконання транзакцій

#### 2.1.1 Створити історію квазіпаралельного успішного виконання транзакцій для протоколу 1-го ступеня блокування.

T1= W[D] W[A] C1
T2= R[D] R[A] W[D] C2
T3= W[B] R[A] W[D] C3

H1(T1,T2,T3) = X1[D] W1[D] R2[D] X3[B] W3[B] X1[A] W1[A] R2[A] R3[A] X2[D]-wait X3[D]-wait C1 U1 X2[D] W2[D] C2 U2 X3[D] W3[D] C3 U3

char* lock_table[][3] = {
{ "A", "X1", ""},
{ "B", "X3", "" },
{ "D", "X1", "X2,X3"}
};

#### 2.1.2 Для створеної історії з попереднього завдання визначити наявність Deadlock-
стану транзакції, створивши граф очікування транзакцій, та зробити відповідний висновок. ####

Представити граф у вигляді масиву на мові програмування С.

int wait[2][2] = {{1, 2}, {2, 3}, {3, 1}};

Цикл знайдено, тому у заданому циклі Deadlock-стан існує. T1 чекає на T2, T2 чекає на T3, T3 чекає на T1.
Це означає, що кожна транзакція чекає на наступну, створюючи цикл залежностей. У такому випадку, якщо кожна транзакція утримує блокування на ресурсі, необхідному наступній транзакції, і чекає на блокування, що утримується наступною транзакцією в циклі, виникає Deadlock-стан.


#### 2.1.3 Створити історію квазіпаралельного успішного виконання транзакцій для ####

протоколу 2-го ступеня блокування.
Описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з
транзакцій у вигляді масиву на мові програмування С.

H2(T1,T2,T3) = X1[D] W1[D] S1[D]-wait X3[B] W3[B] X1[A] W1[A] S2[A]-wait S3[A]-wait X2[D]-wait X3[D]-wait

char* lock_table[][3] = {
{ "A", "S2,S3", "X1"},
{ "B", "", "" },
{ "D", "S1,X2,X3", "X1"}
};
int wait[2][2] = {{1}, {2,3}}{{1}, {1,2,3}};

#### 2.1.4 Для створеної історії з попереднього завдання визначити наявність Deadlock-
стану транзакції, створивши граф очікування транзакцій, та зробити відповідник висновок.
Представити граф у вигляді масиву на мові програмування С. ####

int wait[NUM_TRANSACTIONS][2] = {{1}, {2, 3}};

Цикл не знайдено, тому Deadlock-стан не існує

### 2 Налаштування бази даних

<img width="571" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/214f2854-0830-431b-91d0-413903e94476">

#### Рис 1 - 2.2.1 Встановити з’єднання з БД, назва якої співпадає з іменем вашого користувача
в ОС Linux, використовуючи користувача СКБД за таким же іменем. ####

<img width="570" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/a3c1560a-75c7-4a6b-8091-7d4650e0ab84">

#### Рис 2 - 2.2.2 Виконати команди отримання імені поточного користувача СКБД та назви БД. ####

<img width="574" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/a0adb4b8-c7da-4fb9-8b8b-72e0ab97f2d4">

#### Рис 3 - 2.2.3 У відповідності із варіантом з таблиці 16 створити реляційну таблицю. ####

<img width="570" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/df99a219-774f-4efd-9bda-91e810fef326">

#### Рис 4 - 2.2.4 У відповідності із варіантом з таблиці 16 додати рядок в реляційну таблицю. ####

<img width="572" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/6867ec8b-3d83-46c4-9ed4-4f547c645c7e">


#### Рис 5 - 2.2.5 Створити ще одну операцію внесення рядка в таблицю, який буде відрізнятися
значеннями всіх змінних (стовпчиків) від прикладу з варіанту, а одна із змінних повинна
враховувати значення із транслітерацією вашого прізвища. ####

<img width="570" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/c6de5697-1f9e-4862-a017-25ab9d3a613a">

#### Рис 6 - 2.2.6 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці. ####

<img width="570" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/07eac7d2-1a2b-43e5-82a3-3766f8cf95c1">

#### Рис 6 - 2.2.6 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці. ####

### 3 Керування квазіпаралельним виконанням транзакцій з використанням команд блокування

<img width="574" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/1e637c81-0cc0-453f-9e72-623a8b549649">

<img width="579" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/be664035-02e1-4482-a1bc-594ab1d6206c">

#### Рис 7 - 2.3.1 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_1.sql», наприклад, blazhko_transaction_lock_1.sql, та додати до нього операції двох транзакцій, кожна з яких повинна включати наступні операції:
<ul>
<li>операція блокування для протоколу 1-го ступеня блокування;</li>
<li>операція читання всіх стовпчиків першого рядку таблиці;</li>
<li>операція зміни значення другого стовпчика таблиці у першому рядку;</li>
<li>повторна операція читання всіх стовпчиків першого рядку таблиці;</li>
<li>операція фіксації всіх виконаних операцій.</li>
</ul> ####

<img width="571" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/04fbd1c3-ed1f-4f7d-9672-76595807b932">

#### Рис.8 - 2.3.3 У двох псевдотерміналах виконати операції транзакцій при їх квазіпаралельному режимі роботи за умови, що одна з транзакція стартує першою. ####

<img width="577" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/0ba32108-2554-4dae-a38e-ba735a0cfe4c">

#### Рис.9 - 2.3.4 Повторити роботу транзакцій, але у першій транзакції замість операції фіксації виконати операцію відміни всіх операцій транзакції. ####

<img width="579" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/2dabb988-30ba-4b79-bf8c-46667e36cd4f">

#### Рис.10 - 2.3.5 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_2.sql», наприклад, blazhko_transaction_lock_2.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже враховуючи протокол 2-го ступеня блокування. ####

<img width="576" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/f68c5165-a165-4f07-8565-c96e4dfe5dde">

#### Рис.11 - 2.3.6 Повторити роботу транзакцій з використанням протоколу 2-го ступеня блокування, але з додатковим параметром NOWAIT.

### № 4 Керування квазіпаралельним виконанням транзакцій при наявності Deadlock-станів. ####

<img width="582" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/6b9acf65-4104-40e4-8290-5808db792c3f">

#### Рис.12 - 2.4.1 Створити файл з назвою за шаблоном «ваше прізвище_deadlock.sql», наприклад, blazhko_deadlock.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже модифікованого так, щоб транзакції призводили до Deadlock-стану. ####

<img width="581" alt="image" src="https://github.com/oleksandrblazhko/ai222-rogova/assets/127392599/f2fd3a90-e033-4b1c-bea7-ba82633de65d">

#### Рис.13 - 2.4.2 Виконати модифіковані транзакції. Проаналізувати реакцію СКБД на операцію зміни значення стовпчика для транзакції, яка виконувалася пізніше (призвела до Deadlock-стану), та надати висновки за результатами аналізу з урахуванням ідентифікаторів процесів та номерів транзакцій.

Така послідовність виконання комант призвела до Deadlock-стану, і тому другий термінал завис, і перестав давати доступ до виконання команд, але через особливості OC d MacBook помилка "ERROR: deadlock detected" не виводиться текстом, хоч вона і існує.
