## Керування процесами-транзакціями в базах даних

### 2.1 Теоретичне завдання зі створення історій виконання транзакцій

#### 2.1.1 Створити історію квазіпаралельного успішного виконання транзакцій для
протоколу 1-го ступеня блокування.
TAsk:
T1= W[M] W[K] C1
T2= R[M] R[K] W[M] C2
T3= W[B] R[K] W[M] C3

H1(T1,T2,T3)=X1[M], W1[M], R2[M], X3[B], W3[B], X1[K], W1[K], C1, U1 R1[K], R1[K], X2[M] W2[M], X3[M]-wait, C2, U2, X3[M], W2[M], C3, U3.
Описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з
транзакцій у вигляді масиву на мові програмування С.

:char* lock_table[][3] = {{ "M", "X1", "" },{ "B", "X3", "" },{ "K", "X1", "" }};
#### 2.1.2 Для створеної історії з попереднього завдання визначити наявність Deadlock-
стану транзакції, створивши граф очікування транзакцій, та зробити відповідний висновок.

Представити граф у вигляді масиву на мові програмування С.

int wait[ ][ ] = { {3, 2} };
Висновок:немає циклу dead_lock стану теж немає 

#### 2.1.3 Створити історію квазіпаралельного успішного виконання транзакцій для
протоколу 2-го ступеня блокування.
Описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з
транзакцій у вигляді масиву на мові програмування С.


H2(T1,T2,T3)= X1[M], W1[M], S2[M]-wait, X3[B], W3[B], X1[K], W1[K], C1, U1, S2[K]-wait, S3[K]-wait, X2[M]-wait, X3[M]-wait, U2[M], X2[M], W[M], U2[k], R[K] C2, S3[K], R[K], X3[M], W[M],
, C3
:char* lock_table[][3] = {{ "M", "X1", "S2" },{ "B", "X3", "" },{ "K", "X1", "S2,S3" },{ "M", "s2", "X2" }};


2.1.4

int wait[ ][ ] = { {2, 1},{2 , 1},{3,1},{2,2} };
Висновок:dead_lock є .


### 2.2 Налаштування бази даних

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/5e6d0bd3-8518-4e17-94f0-0f061b92c5f6)

рис 1 до завдання 2.2.1 Встановити з’єднання з БД, назва якої співпадає з іменем вашого користувача
в ОС Linux, використовуючи користувача СКБД за таким же іменем.

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/8b89170d-c3a7-489e-a077-ee41fc0ec526)

рис 2 до завдання 2.2.2 Виконати команди отримання імені поточного користувача СКБД та назви БД.

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/c98f584e-16cd-4d3d-8585-3eb6ec7d23c0)

рис 3 до завдання 2.2.3 У відповідності із варіантом з таблиці 16 створити реляційну таблицю.

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/7b4615f9-3bba-459b-be67-88983a77c29a)

рис 4 до завдання 2.2.4 У відповідності із варіантом з таблиці 16 додати рядок в реляційну таблицю.
![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/5a3b6759-b6a6-4629-88ff-fe0e167d4e4c)

рис 5 до завдання 2.2.5 Створити ще одну операцію внесення рядка в таблицю, який буде відрізнятися
значеннями всіх змінних (стовпчиків) від прикладу з варіанту, а одна із змінних повинна
враховувати значення із транслітерацією вашого прізвища.

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/9dc9e339-95cf-4869-9163-53f812adf0c3)

рис 6 до завдання 2.2.6 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці.


### 2.3 Керування квазіпаралельним виконанням транзакцій з використанням команд блокування

![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/f3270f85-a093-4405-93bd-6b1be4cdfd4f)

Рис. 7 - фрагмент екрану з рiшення "2.3.1 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_1.sql»,
наприклад, blazhko_transaction_lock_1.sql, та додати до нього операції двох транзакцій,
кожна з яких повинна включати наступні операції:
- операція блокування для протоколу 1-го ступеня блокування;
- операція читання всіх стовпчиків першого рядку таблиці;
- операція зміни значення другого стовпчика таблиці у першому рядку;
- повторна операція читання всіх стовпчиків першого рядку таблиці;
- операція фіксації всіх виконаних операцій."


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/cfa018ae-cd88-492b-96ec-1be9116716d8)

Рис. 8 - фрагмент екрану з рiшення "2.3.2 У двох псевдотерміналах виконати операції транзакцій при їх
квазіпаралельному режимі роботи за умови, що одна з транзакція стартує першою."


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/134066ee-92d4-43d3-8308-20600fb2a641)

Рис. 9 - фрагмент екрану з рiшення "2.3.3 Повторити роботу транзакцій, але у першій транзакції замість операції
фіксації виконати операцію відміни всіх операцій транзакції."



![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/30b1c0d4-80f3-4e6f-aff2-c410030d964c)

Рис. 10 - фрагмент екрану з рiшення "2.3.4 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_2.sql»,
наприклад, blazhko_transaction_lock_2.sql, зі змістом файлу, створеного у пункті 2.3.1, але
вже враховуючи протокол 2-го ступеня блокування."


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/28e2c59a-f275-4b1e-86a3-0803ff585eb4)

Рис. 11 - фрагмент екрану з рiшення "2.3.5 Повторити роботу транзакцій з використанням протоколу 2-го ступеня
блокування, але з додатковим параметром NOWAIT."



### 2.4 Керування квазіпаралельним виконанням транзакцій при наявності Deadlock-станів.


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/f75cab05-d716-4111-b6f7-092bca6bef48)

Рис. 12 - фрагмент екрану з рiшення "2.4.1 Створити файл з назвою за шаблоном «ваше прізвище_deadlock.sql»,
наприклад, blazhko_deadlock.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже
модифікованого так, щоб транзакції призводили до Deadlock-стану."


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/0989879e-8d85-4e68-8c34-66131de05457)

### Висновок: ми розробили програму, яка створює дві транзакції. Проте під час їх виконання виникла ситуація, відома як "deadlock" . Це означає, що коли обидва процеси очікують звільнення ресурсів, які потрібні один одному, вони блокуються взаємно. У такій ситуації ніякий з процесів не може продовжити свою роботу, доки не отримає доступ до ресурсів, які зараз заблоковані іншими процесами.

Рис. 13 - фрагмент екрану з рiшення "2.4.2 Виконати модифіковані транзакції. Проаналізувати реакцію СКБД на операцію зміни значення стовпчика для транзакції, яка виконувалася пізніше (призвела до Deadlock-стану), та надати висновки за результатами аналізу з урахуванням ідентифікаторів процесів та номерів транзакцій."
