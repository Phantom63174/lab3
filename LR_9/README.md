## «Основи програмного керування процесами в Unix-подібних ОС»

### 2.1 Перегляд інформації про процес


![image](https://user-images.githubusercontent.com/127674749/236624644-4f3ac42c-17a8-4e71-b0b1-abfc12841f72.png)
![image](https://user-images.githubusercontent.com/127674749/236624658-b1a9453b-8039-4010-bbdc-f4422cb2086a.png)

Рис. 1 - фрагмент екрану з рiшення "2.1.1 Створити C-програму з назвою за шаблоном «ваше прізвище_process_info»,
наприклад, blazhko_process_info яка виводить на екран таку інформацію:
- ідентифікатор групи процесів, до якої належить процес;
- ідентифікатор процесу, що викликав цю функцію;
- ідентифікатор parent-процесу;
- ідентифікатор користувача процесу, який викликав цю функцію;
- ідентифікатор групи користувача процесу, який викликав цю функцію."



![image](https://user-images.githubusercontent.com/127674749/236624714-b499a49f-2053-4f1a-baa1-594f52ef9249.png)

- паралельне виконнання


![image](https://user-images.githubusercontent.com/127674749/236624738-0671a0b2-aa65-4441-a033-08fdfafddf5d.png)
использовал этот но может докопаться 
![image](https://github.com/Phantom63174/lab3/assets/127674749/7e42731f-2930-4445-bfd8-062f9ee5b8a9)
вот его лучше использовать

- конвеєрне виконання


### Висновок: під час паралельного виконання програми, дві окремі копії програми запускаються одночасно та працюють паралельно, виконуючи обчислення одночасно в різних процесах. В конвеєрному виконанні програми, два окремих процеси працюють, один з яких виводить дані, а інший оброблює їх.

Рис. 2 - фрагмент екрану з рiшення "2.1.2 Скомпілювати створену С-програму та запустити її дві копії у двох режимах за
прикладами з рисунку 4:
- паралельне виконання двох процесів;
- конвеєрне виконання двох процесів."


### 2.2 Створення процесу



![image](https://user-images.githubusercontent.com/127674749/236625314-ff88dc07-98f4-4986-80f3-e75ad72f9588.png)

Рис. 3  - фрагмент екрану з рiшення "2.2.1 Створити C-програму, яка породжує процес та замінює образ процесу на
команду у відповідності із варіантом з таблиці 3. Назва програми повинна співпадати з
назвою команди з таблиці 3, але з додатком у вигляді транслітерації вашого прізвища,
наприклад, touch_blazhko."


![image](https://user-images.githubusercontent.com/127674749/236625340-a26249ed-c9cf-405e-a5ac-2f6dcae159bb.png)

Рис. 4 - фрагмент екрану з рiшення "2.2.2 Скомпілювати програму та перевірити її роботу."



### 2.3 Обмін сигналами між процесами


![image](https://user-images.githubusercontent.com/127674749/236625560-9faee23b-9fdd-4eca-8a8f-9d2626fdff05.png)

Рис. 5 - фрагмент екрану з рiшення "2.3.1 Створити C-програму з назвою «ваше прізвище_get_signal», в якій процес
очікує отримання сигналу SIGUSR2 та виводить повідомлення типу Process of Students
Surname got signal після отримання сигналу, де замість слова Students Surname в
повідомленні повинно бути ваше прізвище в транслітерації."


![image](https://user-images.githubusercontent.com/127674749/236625597-b10a3004-c523-4717-a262-fae8cf665578.png)

Рис. 6 - фрагмент екрану з рiшення "2.3.2 Скомпілювати програму та запустити її."



![image](https://user-images.githubusercontent.com/127674749/236625649-9985e883-f84c-4efe-a475-312c633872f8.png)

Рис. 7 - фрагмент екрану з рiшення "2.3.3 Використовуючи інший псевдотермінал, створити C-програму з назвою «ваше
прізвище_set_signal», яка надсилає сигнал SIGUSR2 процесу, запущеному в попередньому
пункті завдання."


![image](https://user-images.githubusercontent.com/127674749/236625716-da343d38-73da-4f44-b1fc-42e6d07e4753.png)

Рис. 8 - фрагмент екрану з рiшення "2.3.4 Скомпілювати другу створену С-програму та запустити її в іншому
псевдотерміналі, проаналізувавши повідомлення, які в першому псевдотерміналі виводить
перша програма.
Завершити процес, запущений в попередньому пункті завдання."


### 2.4 Створення процесу-сироти



![image](https://user-images.githubusercontent.com/127674749/236625898-871f6b00-5554-46b6-9201-26ef6c2e9247.png)

Рис. 9 - фрагмент екрану з рiшення "2.4.1 Створити C-програму з назвою «ваше прізвище_orphan», в якій parent-процес
несподівано завершується раніше child-процесу. Parent-процес повинен очікувати
завершення n+1 секунд.
Child-процес повинен в циклі (2*n+1) разів із затримкою в 1 секунду виводити
повідомлення, наприклад, «Parent of Students` Surname», за шаблоном як в попередньому
завданні, і додатково виводити PPID parent-процесу.
Значення n – номер вашого варіанту."


![image](https://user-images.githubusercontent.com/127674749/236626028-eb025f58-112a-48f0-976d-2dba412139e7.png)
![image](https://user-images.githubusercontent.com/127674749/236626010-d5a397d3-3434-4b42-8788-3f61e885ff79.png)

### Висновок: під час розроблення програм, які взаємодіють з багатьма процесами, важливо детально вивчити механізми створення, зупинки та закінчення процесів, щоб забезпечити їх правильну роботу та уникнути створення блокованих процесів.

Рис. 10 - фрагмент екрану з рiшення "2.4.2 Скомпілювати програму та перевірити її роботу.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."


### 2.5 Створення zombie-процесу


![image](https://user-images.githubusercontent.com/127674749/236626205-cf67e08c-3c8a-42f0-bd79-00ec2e8f8a69.png)

Рис. 11 - фрагмент екрану з рiшення "2.5.1 Створити C-програму з назвою «ваше прізвище_zombie.c», в якій child-процес
несподівано завершується раніше parent-процесу, перетворюється на zombie-процес,
виводячи в результаті повідомлення, наприклад, «I am Zombie-process of Students` Surname»,
за шаблоном як в попередньому завданні."


![image](https://user-images.githubusercontent.com/127674749/236626295-346163e7-5202-42ff-b425-e9fc41a6f6ea.png)
![image](https://user-images.githubusercontent.com/127674749/236626307-41a5c84d-c9ff-447c-a5d8-b3255711dd19.png)

### Висновок: створили программу, яка призводить до створення zombie-процесу.

Рис. 12 - фрагмент екрану з рiшення "2.5.2 Скомпілювати програму та запустити її у фоновому режимі.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."


### 2.6 Попередження створення zombie-процесу


![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/ad7705ed-3373-42f3-81a2-fb7fa294b878)

Рис. 13 - фрагмент екрану з рiшення "2.6.1 Створити C-програму з назвою «ваше прізвище_zombie_stop.c», в якій child-
процес також як в попередньому завданні може перетворитися на zombie-процес, але ця
подія вже повинна контролюватися parent-процесом.
Child-процес повинен виводити повідомлення, наприклад, «Child of Students'
Surname is finished», за шаблоном як в попередньому завданні.
Parent-процес повинен очікувати (3*n) секунд.
Значення n – номер вашого варіанту."



![image](https://github.com/oleksandrblazhko/ai222-turbarov/assets/127674749/e9a9bdcc-30bd-4b3c-beb9-2aa07a35054f)
![image](https://github.com/Phantom63174/lab3/assets/127674749/fadf8019-3890-45b3-a381-e3b26f676158)
может этот видно

### Висновок: необхідно стежити за процесами, контролювати їхні стани і правильно обробляти сигнали, щоб уникнути можливих проблем із зомбі-процесами під час розроблення багатопроцесних застосунків.

Рис. 14 - фрагмент екрану з рiшення "2.6.2 Скомпілювати програму та запустити її у фоновому режимі.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."

